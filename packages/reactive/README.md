Vue2 相比Vue3 响应式的原理：
vue2 采用defineProperty并重写getter和setter对数据进行劫持，
     但是缺点很明显，当新增或删除属性的时候，需要使用$set,$delete进行处理
     同时，对数组需要采取另一种的形式，因为对索引进行劫持也很浪费性能
     不能够检测到数组的变化，所以他进行了方法的包装

Vue3 使用 proxy进行代理，解决了上述问题。
拓展：如何解决？
    proxy是内置一层拦截器对象，任何外部的访问都需要先经过拦截器，不管是新增还是新增属性，都需要经过拦截器。
    同时proxy是可以拦截整个对象的，并返回一个全新的对象，同时能够代理数组

effect -> 是副作用函数，如果所依赖的数据变化，那么就会重新执行一遍
reactive -> 将数据变化为响应式数据

在Reflect中都存在Proxy的方法的一一实现，Reflect是一个非构造函数，使用形式为Math.min，方法都为静态方法

// 主体：
// reactive -> 代表响应式模块，所需要具备的就是能够转换对象为proxy，但是需要提前判断，目标对象是否为对象、是否为proxy、是否已存在
